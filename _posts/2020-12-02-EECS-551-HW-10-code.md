---
title: EECS 551 HW 10 code
date: 2020-12-02 17:15:01 +0800
categories: [Learning, UMICH, EECS551]
tags: [EECS551, UMICH, Data Science, Linear Algebra, DSP, ML]
---
## poly_coeff
```julia
using AbstractAlgebra
using LinearAlgebra
"""
p, q = poly_coeff(a, b, c, d)
Use Kronecker products to construct integer−valued polynomials
with the given (algebraic) numbers as zeros.
In:
* `a, b, c, d` are positive integers
Out:
* `p` and `q` are vectors of length 5 with `p[1] = 1` and `q[1] = 1`
such that, in the notation defined below, `P3(x3) = 0` and `P4(x4) = 0`
Notation:
* `x1 = a + sqrt(b)`
* `x2 = c − sqrt(d)`
* `x3 = x1 + x2`
* `x4 = x1 * x2`
* `P1(x)` a quadratic monic polynomial with integer−valued coefficients with a zero at `x1`
* `P2(x)` a quadratic monic polynomial with integer−valued coefficients with a zero at `x2`
* `P3(x) = x^4 + p[2] x^3 + p[3] x^2 + p[4] x + p[5]`
* `P4(x) = x^4 + q[2] x^3 + q[3] x^2 + q[4] x + q[5]`
"""
function poly_coeff(a, b, c, d)
    A = [2*a -(a^2-b); 1 0];
    B = [2*c -(c^2-d); 1 0];
    C = matrix(ZZ, kron(A,Matrix(I,2,2))+kron(Matrix(I,2,2),B));
    Zx, x = ZZ["x"];
    p = convert(Array{Int64,1},charpoly(Zx, C).coeffs[end:-1:1]);
    C = matrix(ZZ, kron(A,B));
    q = convert(Array{Int64,1},charpoly(Zx, C).coeffs[end:-1:1]);
    return p,q
end
```
## lssd
``` 
using LinearAlgebra
"""
x = lssd(A, b ; x0=zeros(size(A,2)), nIters::Int=10)
Perform steepest descent to solve the least squares problem
`\\min_x \\| b − A x \\|_2`
In:
* `A` a `m x n` matrix
* `b` a vector of length `m`
Option:
* `x0` is the initial starting vector (of length `n`) to use; default `zeros`
* `nIters` number of iterations to perform; default `10`
Out:
* `x` a vector of length `n` containing the approximate solution
Notes:
Because this is a quadratic cost function, there is a closed−form solution
for the step size each iteration, so no "line search" procedure is needed.
A full−credit solution uses only *one* multiply by `A` and one by `A'` per iteration.
"""
function lssd(A, b ; x0=zeros(size(A,2)), nIters::Int=10)
    Q = A'*A;
    for i = 1:nIters
        gk = A'*((A*x0)-b);
        x0 -= (gk'*gk)/((gk'*Q)*gk)*gk;
    end
    return x0
end
```